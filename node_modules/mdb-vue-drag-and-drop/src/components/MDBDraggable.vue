<template>
  <component :class="className" :is="tag" ref="draggableElement"
    ><slot
  /></component>
</template>

<script>
import { computed, ref, onMounted, onUnmounted } from "vue";

export default {
  name: "MDBDraggable",

  props: {
    blockXAxis: Boolean,
    blockYAxis: Boolean,
    container: String,
    delay: Number,
    disabled: Boolean,
    draggingClass: String,
    dragHandle: String,
    scrollPixels: {
      type: Number,
      default: 40,
    },
    tag: {
      type: String,
      default: "div",
    },
  },
  emits: ["start", "move", "end"],
  setup(props, { emit }) {
    const className = computed(() => [
      props.disabled || props.dragHandle ? "" : "draggable-cursor-grab",
      isDragging.value && "dragging",
      isDragging.value && props.draggingClass,
    ]);

    const isDragging = ref(false);
    const draggableElement = ref(null);
    let dragHandler = null;

    let container = null;
    let containerRect = null;
    let draggableRect = null;
    let defaultX = 0;
    let defaultY = 0;

    onMounted(() => {
      if (props.disabled) {
        return;
      }

      if (props.dragHandle) {
        setDragHandler();
      }

      draggableElement.value.addEventListener("mousedown", onMousedown);
      draggableElement.value.addEventListener("touchstart", onTouchstart);
      draggableElement.value.addEventListener("touchmove", onTouchmove);

      document.addEventListener("mousemove", onMousemove);
      document.addEventListener("mouseup", onDragend);
      document.addEventListener("touchend", onDragend);

      if (!props.container) {
        return;
      }

      container = props.container
        ? document.querySelector(props.container)
        : null;
      containerRect = container.getBoundingClientRect();
      draggableRect = draggableElement.value.getBoundingClientRect();

      defaultX = draggableRect.x - containerRect.x;
      defaultY = draggableRect.y - containerRect.y;

      window.addEventListener("resize", onResize);
    });

    onUnmounted(() => {
      if (props.disabled) {
        return;
      }

      if (draggableElement.value) {
        draggableElement.value.removeEventListener("mousedown", onMousedown);
        draggableElement.value.removeEventListener("touchstart", onTouchstart);
        draggableElement.value.removeEventListener("touchmove", onTouchmove);
      }

      if (dragHandler) {
        dragHandler.removeEventListener("mousedown", onMousedown);
        dragHandler.removeEventListener("touchstart", onTouchstart);
        dragHandler.removeEventListener("touchmove", onTouchmove);
      }

      document.removeEventListener("mousemove", onMousemove);
      document.removeEventListener("mouseup", onDragend);
      document.removeEventListener("touchend", onDragend);

      if (props.container) {
        window.removeEventListener("resize", onResize);
      }
    });

    const setDragHandler = () => {
      dragHandler = draggableElement.value.querySelector(props.dragHandle);
      draggableElement.value = dragHandler;
      dragHandler.classList.add("draggable-cursor-grab");
    };

    let mouseX = 0;
    let mouseY = 0;
    let elementX = 0;
    let elementY = 0;
    let deltaX = 0;
    let deltaY = 0;

    let x = 0;
    let y = 0;

    // drag
    const onDrag = (event) => {
      x = elementX + deltaX;
      y = elementY + deltaY;

      if (props.container) {
        onDragWithContainer(x, y);
      } else {
        onDragWithoutContainer(x, y);
      }

      emit("move", event);
    };

    const onDragWithoutContainer = (x, y) => {
      if (props.delay) {
        moveWithDelay(x, y);
      } else {
        moveWithoutDelay(x, y);
      }
    };

    const moveWithDelay = (x, y) => {
      setTimeout(() => {
        draggableElement.value.style.transform = `translate3d(${x}px, ${y}px, 0)`;
      }, props.delay);
    };

    const moveWithoutDelay = (x, y) => {
      draggableElement.value.style.transform = `translate3d(${x}px, ${y}px, 0)`;
    };

    const onDragWithContainer = (x, y) => {
      draggableRect = draggableElement.value.getBoundingClientRect();

      if (x < -defaultX) {
        x = -defaultX;
      }
      if (x > container.scrollWidth - draggableRect.width - defaultX) {
        x = container.scrollWidth - draggableRect.width - defaultX;
      }
      if (y < -defaultY) {
        y = -defaultY;
      }
      if (y > container.scrollHeight - draggableRect.height - defaultY) {
        y = container.scrollHeight - draggableRect.height - defaultY;
      }

      if (
        x >
        containerRect.width +
          container.scrollLeft -
          draggableRect.width -
          defaultX -
          props.scrollPixels
      ) {
        container.scrollLeft = container.scrollLeft + 10;
      }
      if (x < container.scrollLeft - defaultX + props.scrollPixels) {
        container.scrollLeft = container.scrollLeft - 10;
      }
      if (
        y >
        containerRect.height +
          container.scrollTop -
          draggableRect.height -
          defaultY -
          props.scrollPixels
      ) {
        container.scrollTop = container.scrollTop + 10;
      }
      if (y < container.scrollTop - defaultY + props.scrollPixels) {
        container.scrollTop = container.scrollTop - 10;
      }

      if (props.blockXAxis) {
        x = 0;
      }
      if (props.blockYAxis) {
        y = 0;
      }

      if (props.delay) {
        moveWithDelay(x, y);
      } else {
        moveWithoutDelay(x, y);
      }
    };

    const onDragend = (event) => {
      isDragging.value = false;

      if (props.dragHandle) {
        dragHandler.classList.remove("dragging");
      }

      elementX += deltaX;
      elementY += deltaY;
      deltaX = 0;
      deltaY = 0;

      emit("end", event);
    };

    // mouse
    const onMousedown = (event) => {
      mouseX = event.clientX;
      mouseY = event.clientY;

      isDragging.value = true;

      if (props.dragHandle) {
        dragHandler.classList.add("dragging");
      }

      emit("start", event);
    };

    const onMousemove = (event) => {
      if (!isDragging.value) {
        return;
      }

      deltaX = event.clientX - mouseX;
      deltaY = event.clientY - mouseY;

      onDrag(event);
    };

    // touch
    const onTouchstart = (event) => {
      mouseY = event.touches[0].clientY;
      mouseX = event.touches[0].clientX;

      isDragging.value = true;

      emit("start", event);
    };

    const onTouchmove = (event) => {
      event.preventDefault();

      if (!isDragging.value) {
        return;
      }

      deltaX = event.touches[0].clientX - mouseX;
      deltaY = event.touches[0].clientY - mouseY;

      onDrag(event);
    };

    const resetPosition = () => {
      containerRect = container.getBoundingClientRect();
      draggableRect = draggableElement.value.getBoundingClientRect();

      defaultX = draggableRect.x - containerRect.x;
      defaultY = draggableRect.y - containerRect.y;

      mouseX = 0;
      mouseY = 0;
      elementX = 0;
      elementY = 0;
      deltaX = 0;
      deltaY = 0;

      x = 0;
      y = 0;

      if (props.container) {
        onDragWithContainer(x, y);
      } else {
        onDragWithoutContainer(x, y);
      }
    };

    const onResize = () => {
      resetPosition();
    };

    return {
      className,
      draggableElement,
      onMousedown,
      onTouchstart,
      onTouchmove,
      resetPosition,
    };
  },
};
</script>
