<template>
  <component
    :class="className"
    :is="tag"
    :id="uid"
    ref="sortableList"
    :data-mdb-drag-handle="dragHandle ?? null"
  >
    <slot />
  </component>
  <teleport to="body">
    <MDBDraggable
      v-html="draggingItem.el.innerHTML"
      :tag="draggingItem.el.nodeName"
      :class="`${draggingItem.el.className} sortable-item-dragging`"
      :style="draggingItemStyle"
      :id="draggingItem.helperId"
      ref="helperEl"
      v-if="draggingItem"
    />
  </teleport>
</template>

<script>
import { ref, computed, nextTick, onMounted, watchEffect } from "vue";
import MDBDraggable from "./MDBDraggable.vue";
import { getUID } from "../utils/getUID";
import Manipulator from "../utils/manipulator";

export default {
  name: "MDBSortable",
  components: {
    MDBDraggable,
  },
  props: {
    tag: {
      type: String,
      default: "div",
    },
    sorting: {
      type: Boolean,
      default: true,
    },
    animationDuration: {
      type: Number,
      default: 300,
    },
    classes: String,
    connectedList: Object,
    copy: Boolean,
    id: String,
    enterPredicate: {
      type: Function,
      default: () => true,
    },
    itemClass: {
      type: String,
      default: "sortable-item",
    },
    dragHandle: String,
  },
  emits: ["start", "move", "exit"],
  setup(props, { emit }) {
    const className = computed(() => {
      return ["sortable-list", props.classes];
    });
    const sortableList = ref(null);
    const sortableItems = ref([]);
    const inactiveSortableItems = ref([]);
    const draggingItem = ref(null);
    const hasInit = ref(false);
    const draggingItemStyle = ref(null);
    const helperEl = ref(null);
    const uid = ref(props.id || getUID("mdb-sortable-"));
    const animateTimeExecution = ref(props.animationDuration / 1000);

    const connectedListInstance = ref(props.connectedList);
    watchEffect(() => (connectedListInstance.value = props.connectedList));

    const getSortableItems = () => {
      const selector = `.${props.itemClass}`;

      return sortableList.value.querySelectorAll(selector);
    };

    const addSortableItem = (sortableItem) => {
      sortableItems.value.push(sortableItem);
    };

    const getHandler = (el) => {
      const hasDragHandler = el.hasAttribute("data-mdb-drag-handle");
      if (hasDragHandler) {
        const handlerSelector = el.getAttribute("data-mdb-drag-handle");
        let dragHandler = el.querySelector(handlerSelector);
        dragHandler = dragHandler ?? el;
        return dragHandler;
      }

      return el;
    };

    const createSortableItemsList = () => {
      getSortableItems().forEach((node, index) => {
        const handlerForDrag = getHandler(node);

        const item = {
          id: getUID(`${props.itemClass}-`),
          el: node,
          index,
          helperEl: null,
          handlerEl: null,
          offsetTop: node.offsetTop,
          offsetLeft: node.offsetLeft,
          translateX: 0,
          translateY: 0,
          initialDisplay: window
            .getComputedStyle(node, null)
            .getPropertyValue("display"),
          returnAnimation: true,
          handlerForDrag,
        };
        node.setAttribute("data-mdb-id", item.id);
        addSortableItem(item);
      });
    };

    const addItem = (el, index, item = {}) => {
      if (typeof index !== "number") {
        index = sortableItems.value.length;
      }

      const handlerForDrag = getHandler(el);

      const newItem = {
        id: getUID(`${props.itemClass}-`),
        el,
        index,
        handlerEl: null,
        helperEl: null,
        offsetTop: null,
        offsetLeft: null,
        translateX: 0,
        translateY: 0,
        initialDisplay: window
          .getComputedStyle(el, null)
          .getPropertyValue("display"),
        returnAnimation: true,
        handlerForDrag,
        ...item,
      };

      el.setAttribute("data-mdb-id", newItem.id);
      setDragStartListener(newItem.handlerForDrag);
      pushItemBetween(index, newItem);
    };

    const makeItemsSortable = () => {
      sortableItems.value.forEach((item) => {
        const options = Manipulator.getDataAttributes(item.el);
        item.options = options;

        if (!item.options.disabled) {
          setDragStartListener(item.handlerForDrag);
        }
      });
    };

    const setDragStartListener = (item) => {
      item.addEventListener("mousedown", handleDragStart);
      item.addEventListener("touchstart", handleDragStart);
    };

    onMounted(() => {
      createSortableItemsList();
      makeItemsSortable();
    });

    const handleDragStart = () => {
      addCursorMove();

      window.addEventListener("mousemove", initSortableItems);
      window.addEventListener("touchmove", initSortableItems);
    };

    const findInParentElements = (el, selector) => {
      const parents = [];

      let ancestor = el.parentNode;

      while (
        ancestor &&
        ancestor.nodeType === Node.ELEMENT_NODE &&
        ancestor.nodeType !== 3
      ) {
        if (ancestor.matches(selector)) {
          parents.push(ancestor);
        }

        ancestor = ancestor.parentNode;
      }

      return parents;
    };

    const setDraggingItem = (e) => {
      const properTarget = e.target.classList.contains(props.itemClass);
      const target = properTarget
        ? e.target
        : findInParentElements(e.target, `.${props.itemClass}`)[0];

      const activeItem = sortableItems.value.filter(
        (node) => node.id === target.getAttribute("data-mdb-id")
      )[0];

      if (activeItem) {
        draggingItem.value = activeItem;
        draggingItem.value.helperId = getUID("dragging-item-");
      }
    };

    const setDraggingItemStyle = (e) => {
      if (!draggingItem.value) {
        return;
      }
      draggingItemStyle.value = getDraggingItemStyle(e, draggingItem.value.el);

      nextTick(() => {
        const helperEl = getItem(draggingItem.value.helperId);
        draggingItem.value.helperEl = helperEl;
      });
    };

    const createHandler = () => {
      const handlerEl = draggingItem.value.el.cloneNode(true);
      handlerEl.style.visibility = props.copy ? "visible" : "hidden";

      const parentEl = draggingItem.value.el.parentNode;
      draggingItem.value.handlerEl = handlerEl;
      parentEl.insertBefore(handlerEl, draggingItem.value.el);
    };

    const setInactiveItemsStyle = () => {
      inactiveSortableItems.value.forEach((item) => {
        item.el.style.transition = `transform ${animateTimeExecution.value}s`;
        item.el.addEventListener("mouseenter", handleMouseEnter);
      });
    };

    const hideOriginalItem = () => {
      draggingItem.value.el.style.display = "none";
      document.body.appendChild(draggingItem.value.el);
    };

    const triggerStartEvent = (e) => {
      emit("start", e.target);
    };

    const setEvents = (e) => {
      inactiveSortableItems.value = sortableItems.value.filter(
        (item) => item.id !== draggingItem.value.helperId
      );

      if (props.sorting) {
        setInactiveItemsStyle();
      }
      window.addEventListener("mouseup", handleMouseUp);

      nextTick(() => {
        helperEl.value.onMousedown(e);
        if (connectedListInstance.value) {
          setHandlersForConnectedTab();
        }
      });
    };

    const initSortableItems = (e) => {
      if (hasInit.value) {
        return;
      }
      hasInit.value = true;

      triggerStartEvent(e);
      setDraggingItem(e);

      if (!draggingItem.value) {
        return;
      }
      setDraggingItemStyle(e);
      createHandler();
      hideOriginalItem();
      setEvents(e);
    };

    const getItem = (id) => {
      return document.getElementById(id);
    };

    const getDraggingItemStyle = (e, draggingItem) => {
      if (!draggingItem) {
        return;
      }

      const { height, width, top, left } = draggingItem.getBoundingClientRect();

      const shiftY = e.clientY - top;
      const shiftX = e.clientX - left;

      const elTop = `${e.clientY - shiftY}px`;
      const elLeft = `${e.clientX - shiftX}px`;

      return {
        width: `${width}px`,
        height: `${height}px`,
        position: "fixed",
        top: elTop,
        left: elLeft,
        opacity: props.copy ? "0.5" : "1",
      };
    };

    const getTarget = (e) => {
      const properTarget = e.target.classList.contains(props.itemClass);
      const target = properTarget
        ? e.target
        : findInParentElements(e.target, `.${props.itemClass}`)[0];
      return sortableItems.value.filter(
        (item) => item.id === target.getAttribute("data-mdb-id")
      )[0];
    };

    const getItemsToMove = (itemBelow, enteredItem) => {
      return sortableItems.value.filter((item) => {
        if (itemBelow) {
          return (
            draggingItem.value.index < item.index &&
            item.index <= enteredItem.index
          );
        }

        return (
          draggingItem.value.index > item.index &&
          item.index >= enteredItem.index
        );
      });
    };

    const slideItems = (itemBelow, itemsToMove) => {
      itemsToMove.forEach((item) => {
        const index = itemBelow ? item.index - 1 : item.index + 1;
        const previousItem = sortableItems.value[index];

        const distanceY = previousItem.offsetTop - item.offsetTop;
        const distanceX = previousItem.offsetLeft - item.offsetLeft;

        item.translateY = distanceY;
        item.translateX = distanceX;

        setTranslate(item.el, distanceX, distanceY);
      });
    };

    const slideHandler = () => {
      let sumY = 0;
      let sumX = 0;

      sortableItems.value.forEach((item) => {
        sumY -= item.translateY;
        sumX -= item.translateX;
      });

      setTranslate(draggingItem.value.handlerEl, sumX, sumY);
    };

    const setIndexes = (itemsToMove, itemBelow) => {
      sortableItems.value = sortableItems.value.map((sortableItem) => {
        itemsToMove.forEach((itemToSlide) => {
          if (sortableItem.id === itemToSlide.id) {
            if (itemBelow) {
              itemToSlide.index--;
            } else {
              itemToSlide.index++;
            }
          }
        });

        return sortableItem;
      });
    };

    const handleMouseEnter = (e) => {
      const enteredItem = getTarget(e);
      emit("move", { target: enteredItem.el });

      const itemBelow = enteredItem.index > draggingItem.value.index;
      const itemsToMove = getItemsToMove(itemBelow, enteredItem);

      slideItems(itemBelow, itemsToMove);
      slideHandler();

      draggingItem.value.index = enteredItem.index;
      setIndexes(itemsToMove, itemBelow);
    };

    const handleMouseUp = () => {
      if (!draggingItem.value) {
        return;
      }
      setTranslate(draggingItem.value.handlerEl, 0, 0);

      sortableItems.value.forEach((item) => {
        item.el.removeEventListener("mouseenter", handleMouseEnter);
        item.el.style.transition = "";
        setTranslate(item.el, 0, 0);
      });

      sortableItems.value = sortableItems.value.sort(sortIndex);

      removeCursorMove();
      rerenderList();
      swapElements();
      setOffsets();
      resetTranslatesInfo();
      turnOffEvents();
    };

    const rerenderList = () => {
      sortableItems.value.forEach((item) => {
        if (item.id !== draggingItem?.value.id) {
          sortableList.value.appendChild(item.el);
        } else {
          sortableList.value.appendChild(draggingItem.value.handlerEl);
        }
      });
    };

    const resetTranslatesInfo = () => {
      sortableItems.value.forEach((item) => {
        item.translateX = 0;
        item.translateY = 0;
      });
    };

    const swapElements = () => {
      const { posX, posY } = getPositions();
      setOriginalElPosition();
      startElReturnAnimation(posX, posY);
    };

    const startElReturnAnimation = (posX, posY) => {
      draggingItem.value.el.style.visibility = "visible";
      draggingItem.value.helperEl.style.visibility = "hidden";
      setTranslate(draggingItem.value.el, posX, posY);
      draggingItem.value.handlerEl.remove();

      setTimeout(() => {
        const animationBlocked = draggingItem.value.returnAnimation;
        if (animationBlocked) {
          draggingItem.value.el.style.transition = `transform ${animateTimeExecution.value}s`;
        }
        setTranslate(draggingItem.value.el, 0, 0);
      });

      setTimeout(() => {
        draggingItem.value.el.style.visibility = "";
        draggingItem.value.el.style.transition = "";

        draggingItem.value = null;
      }, props.animationDuration);
    };

    const getPositions = () => {
      draggingItem.value.handlerEl.style.visibility = "visible";
      const { top: elTop, left: elLeft } =
        draggingItem.value.helperEl.getBoundingClientRect();
      const { top: refTop, left: refLeft } =
        draggingItem.value.handlerEl.getBoundingClientRect();

      const posX = elLeft - refLeft;
      const posY = elTop - refTop;

      return { posX, posY };
    };

    const setOriginalElPosition = () => {
      draggingItem.value.handlerEl.parentNode.insertBefore(
        draggingItem.value.el,
        draggingItem.value.handlerEl
      );
      draggingItem.value.el.style.display = draggingItem.value.initialDisplay;
    };

    const pushItemBetween = (index, item) => {
      sortableItems.value.splice(index, 0, item);
      rewriteIndexes();
    };

    const rewriteIndexes = () => {
      sortableItems.value = sortableItems.value.map((item, index) => {
        item.index = index;
        return item;
      });
    };

    const sortIndex = (objOne, objTwo) => {
      const indexOne = objOne.index;
      const indexTwo = objTwo.index;

      let comprasion = 0;
      if (indexOne > indexTwo) {
        comprasion = 1;
      } else if (indexOne < indexTwo) {
        comprasion = -1;
      }

      return comprasion;
    };

    const setOffsets = () => {
      sortableItems.value.forEach((item) => {
        item.offsetLeft = item.el.offsetLeft;
        item.offsetTop = item.el.offsetTop;
      });
    };

    const setTranslate = (el, x, y) => {
      el.style.transform = `translate3d(${x}px, ${y}px, 0px)`;
    };

    const turnOffEvents = () => {
      hasInit.value = false;
      sortableItems.value.forEach((item) => {
        item.el.removeEventListener("mouseenter", handleMouseEnter);
      });
      window.removeEventListener("mousemove", initSortableItems);
      window.removeEventListener("touchmove", initSortableItems);
      window.removeEventListener("mouseup", handleMouseUp);
      window.removeEventListener("touchend", handleMouseUp);
    };

    const hasProperValue = () => {
      const predicateValue =
        draggingItem.value.el.getAttribute("data-mdb-value");
      const predicated = props.enterPredicate(predicateValue);
      return predicated;
    };

    const addCursorMove = () => {
      document.body.classList.add("cursor-drag");
    };
    const removeCursorMove = () => {
      document.body.classList.remove("cursor-drag");
    };

    /**
     * ---------------- Connected lists -----------------
     */

    const setHandlersForConnectedTab = () => {
      connectedListInstance.value.sortableList.addEventListener(
        "mouseover",
        handleMouseOverConnTab,
        false
      );
    };

    const handleMouseOverConnTab = (e) => {
      if (!draggingItem.value) {
        return;
      }
      connectedListInstance.value.sortableList.removeEventListener(
        "mouseover",
        handleMouseOverConnTab,
        false
      );
      if (hasProperValue()) {
        emit("exit", { target: connectedListInstance.value.sortableList });

        if (props.copy) {
          copyItems(e);
        } else {
          sendItem(e);
        }
      }
    };

    const copyItems = (e) => {
      const connTabInstance = connectedListInstance.value;
      const isListItem =
        e.target.classList.contains(props.itemClass) ||
        e.target.closest(`.${props.itemClass}`);
      const isTableContainer = e.target.classList.contains("sortable-list");
      const dragStyle = getDraggingItemStyle(e, draggingItem.value.helperEl);
      draggingItem.value.returnAnimation = false;

      if (isListItem) {
        const enteredItem = connTabInstance.sortableItems.filter(
          (item) => item.id === e.target.getAttribute("data-mdb-id")
        )[0];

        const offTop = enteredItem.el.offsetTop;
        const offLeft = enteredItem.el.offsetLeft;

        const enteredElParent = enteredItem.el.parentNode;

        const copyEl = draggingItem.value.el.cloneNode(true);
        copyEl.style.display = draggingItem.value.initialDisplay;
        enteredElParent.insertBefore(copyEl, enteredItem.el);
        connTabInstance.setOffsets();

        connTabInstance.addItem(copyEl, enteredItem.index, {
          offTop,
          offLeft,
        });
        connTabInstance.setDraggingItem({ target: copyEl });

        // set dragging item on connected list based on added item
        nextTick(() => {
          setConnTabDraggingItemStyle(dragStyle, true, offTop, offLeft);

          window.setTimeout(() => {
            setConnTabEvents(e, true);

            draggingItem.value.helperEl.style.opacity = "0";
          });
        });
      } else if (isTableContainer) {
        const copyEl = draggingItem.value.el.cloneNode(true);
        copyEl.style.display = draggingItem.value.initialDisplay;

        connTabInstance.sortableList.appendChild(copyEl);

        connTabInstance.addItem(copyEl);
        connTabInstance.setDraggingItem({ target: copyEl });

        // set dragging item on connected list based on added item
        nextTick(() => {
          setConnTabDraggingItemStyle(dragStyle, true);

          window.setTimeout(() => {
            setConnTabEvents(e, true);

            draggingItem.value.helperEl.style.opacity = "0";
          });
        });
      }
    };

    const sendItem = (e) => {
      const connTabInstance = connectedListInstance.value;
      const isListItem =
        e.target.classList.contains(props.itemClass) ||
        e.target.closest(`.${props.itemClass}`);
      const isTableContainer = e.target.classList.contains("sortable-list");
      const dragStyle = getDraggingItemStyle(e, draggingItem.value.helperEl);

      if (isListItem) {
        turnOffEvents();
        const enteredItem = connTabInstance.sortableItems.filter(
          (item) => item.id === e.target.getAttribute("data-mdb-id")
        )[0];

        const offTop = enteredItem.el.offsetTop;
        const offLeft = enteredItem.el.offsetLeft;

        // remove item from the original list
        sortableItems.value = sortableItems.value.filter(
          (item) => item.id !== draggingItem.value.id
        );

        connTabInstance.draggingItem = draggingItem.value;
        connTabInstance.draggingItem.index = enteredItem.index;

        // push original item to connected list
        connTabInstance.pushItemBetween(
          enteredItem.index,
          connTabInstance.draggingItem
        );
        enteredItem.el.parentNode.insertBefore(
          connTabInstance.draggingItem.handlerEl,
          enteredItem.el
        );

        rerenderList();

        connTabInstance.setOffsets();

        resetOriginalList();

        // set dragging item on connected list based on added item
        nextTick(() => {
          setConnTabDraggingItemStyle(dragStyle, false, offTop, offLeft);
          window.setTimeout(() => setConnTabEvents(e));
        });
      } else if (isTableContainer) {
        turnOffEvents();

        connTabInstance.draggingItem = draggingItem.value;
        connTabInstance.draggingItem.index =
          connTabInstance.sortableItems.length;

        // remove item from the original list
        sortableItems.value = sortableItems.value.filter((item) => {
          return item.id !== draggingItem.value.id;
        });

        resetOriginalList();

        // push original item to connected list
        connTabInstance.sortableItems = [
          ...connTabInstance.sortableItems,
          connTabInstance.draggingItem,
        ];

        connTabInstance.sortableList.appendChild(
          connTabInstance.draggingItem.handlerEl
        );
        // // set dragging item on connected list based on added item
        nextTick(() => {
          setConnTabDraggingItemStyle(dragStyle);
          window.setTimeout(() => setConnTabEvents(e));
        });
      }
    };

    const resetOriginalList = () => {
      draggingItem.value = null;

      resetTranslatesInfo();
      rewriteIndexes();
    };

    const setConnTabDraggingItemStyle = (
      dragStyle,
      isCopy = false,
      offTop = null,
      offLeft = null
    ) => {
      const connTabInstance = connectedListInstance.value;

      connTabInstance.draggingItemStyle = dragStyle;
      connTabInstance.draggingItem.helperEl = getItem(
        connTabInstance.draggingItem.helperId
      );
      if (isCopy) {
        connTabInstance.createHandler();
        connTabInstance.hideOriginalItem();
        connTabInstance.draggingItem.handlerEl.style.visibility = "visible";
      }

      offTop = offTop ?? connTabInstance.draggingItem.handlerEl.offsetTop;
      offLeft = offLeft ?? connTabInstance.draggingItem.handlerEl.offsetLeft;

      connTabInstance.draggingItem.offsetTop = offTop;
      connTabInstance.draggingItem.offsetLeft = offLeft;
    };

    const setConnTabEvents = (e, isCopy = false) => {
      connectedListInstance.value.hasInit = true;
      connectedListInstance.value.setEvents(e);

      if (!isCopy) {
        setConnTabDraggingItemDragListener();
      }
    };

    const setConnTabDraggingItemDragListener = () => {
      connectedListInstance.value.draggingItem.handlerForDrag.addEventListener(
        "mousedown",
        connectedListInstance.value.handleDragStart
      );
      connectedListInstance.value.draggingItem.handlerForDrag.addEventListener(
        "touchstart",
        connectedListInstance.value.handleDragStart
      );
    };

    return {
      sortableList,
      uid,
      animateTimeExecution,
      sortableItems,
      className,
      draggingItem,
      draggingItemStyle,
      helperEl,
      handleMouseUp,
      handleDragStart,
      handleMouseEnter,
      pushItemBetween,
      setDraggingItem,
      getDraggingItemStyle,
      hasInit,
      setEvents,
      setOffsets,
      addItem,
      rerenderList,
      createHandler,
      hideOriginalItem,
      initSortableItems,
      handleMouseOverConnTab,
    };
  },
};
</script>
